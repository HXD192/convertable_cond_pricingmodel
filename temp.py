import numpy as np
from time import time
import pandas as pd
import math
import datetime
from arch import arch_model
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from matplotlib.font_manager import FontProperties
from urllib.request import urlretrieve
import os

def underlying_price(reps, N, S_0, r, sigma, dt, data_time):    
    '''
    Simulate the underlying stock price paths by Geometric Brownian motion with mean "r" and volatility "sigma".

    Args:
        reps: number of simulated underlying price paths generated by Geometric Brownian Motion
        N: number of time intervals until maturity
        S_0: initial stock price
        r: (annualized) riskfree interest rate (mean of the GBM)
        sigma: (annualized) volatility (standard deviation) of the GBM
        dt: time difference factor
        
    Return:
        S: the matrix of the underlying stock price paths given in each discretized time point (in numpy.array)
    
    '''
    S = np.empty([reps,N+1]) # 'reps' sample paths of GBM(r,sigma) movement
    for i in range(reps):    
        one_path = S_0*np.cumprod(np.exp((r-(sigma**2)/2)*dt + sigma*np.sqrt(dt)*np.random.normal(0,1,N))) # one GBM increment
        one_path = np.insert(one_path,0,S_0) # add the initial stock price at inception
        S[i,] = one_path
    res= pd.DataFrame(S,index = np.arange(reps),columns = data_time.values.flatten()).applymap(lambda x:round(x,2))
    return S,res

from dateutil.parser import parse

bond_paper_rate = 0.01 #年化
def Judge_redeem(x:np.ndarray,S):
    data = x.flatten()
    for i in range(30,x.shape[0]):
        temp_data = data[i-30:i]
        if (np.sum(temp_data >= S) >=15):
            temp_data_index = np.where(np.sum(temp_data >= S)>=15)[0][0]
            target_index = temp_data_index + i
            break;
    else:
        target_index = None
    return target_index

def redeem_discount(x,target_index,K,bond_rate_gap_year,discount_year,bond_paper_rate):#x是起息日之后的数据
    target_data = x[:target_index+1]
    target_price = target_data[-1]
    all_year = (target_index + bond_rate_gap_year)/244
    discount_year = (target_index + gap_day)/244
    res = (100*target_price/K + 100*bond_paper_rate*all_year)*np.exp(-r*discount_year)
    return res

def get_redeem_price(x:np.ndarray,S,K,bond_rate_gap_year,discount_year,bond_paper_rate):
    #select_date_span
    x = x[huangu_start_day_ind:]
    target_index = Judge_redeem(x,S)
    if target_index:
        price = redeem_discount(x,target_index,bond_rate_gap_year,all_year,discount_year,bond_paper_rate)#target_index是从换股起息日开始计算
        return price
    else: #没有满足
        return None
    
#回售条款 任意连续30个交易日
def Judge_sell_back(x:np.ndarray,S):
    #最后244个交易日
    data = x.flatten()
    for i in range(30,x.shape[0]):
        temp_data = data[i-30:i]
        if (temp_data <= S).all():
            return i
    else:
        return None
    
def redeem_discount_sell_back(x,target_index,bond_paper_rate):#
    target_data = x
    all_year_num = (df.shape[1] - 244 + target_index);
    all_year = all_year_num/244
    discount_year = (all_year_num + 24)/244
    res = (100 + 100*bond_paper_rate*all_year)*np.exp(-r*discount_year) 
    return res

def get_redeem_sell_back(x:np.ndarray,S,bond_paper_rate):
    """
    倒数244个交易日
    """
    x = x[-244:]
    target_index = Judge_sell_back(x,S)
    if target_index:
        price = redeem_discount_sell_back(x,target_index,bond_paper_rate)
        return price
    else:
        return None
    
def least_square_monte_carlo(df,Price,K):
    """
    Price:行权价
    K:基本行权价 Price = K
    df:所有有效路径
    """
    value = np.empty([df.shape[0],df.shape[1]])
    for i in range(df.shape[1]-1,-1,-1):
        S_current = df[:,i]
        if i == df.shape[1] - 1:     
            def judge_end(nd:np.ndarray,Price):
                if nd > Price:
                    return nd*100/K
                elif nd <= Price:
                    return Price*100/K
            judge_np = np.vectorize(judge_end)
            value[:,i] = judge_np(S_current,Price)
        elif i == 0:
            for z in range(df.shape[0]):
                current_path = value[z,1:]
                nonzero_loc = current_path.nonzero()
                if len(nonzero_loc[0]) == 0:
                    value[z,i] = 0
                else:
                    first_nonzero_loc = nonzero_loc[0][0]
                    dt = 1/244
                    value[z,i] = np.exp(-r*dt*(first_nonzero_loc + 1))*current_path[first_nonzero_loc]
        else:
            in_the_money_loc = ((S_current - Price)*(S_current>Price)).nonzero()
            length = len(in_the_money_loc[0])
            exercise_value = ((S_current*100/K) * (S_current > Price))[in_the_money_loc]
            X = np.empty([length,2])
            for j in range(1,3):
                X[:,j-1] = np.power(S_current[in_the_money_loc],j)
            previous_continuation_value = value[:,i + 1][in_the_money_loc]
            dt = 1/244
            Y = np.exp(-r*dt)*previous_continuation_value
            try:
                length >=10
            except:
                raise Exception("实值行情少于10行")
            predicted_conditional_exp = LinearRegression().fit(X, Y).predict(X)
            value[:,i] = [0]*df.shape[0]
            exercise_immediate_loc = (exercise_value > predicted_conditional_exp)
            optimal_loc = in_the_money_loc[0][exercise_immediate_loc]
            optimal_cash_flow = exercise_value[exercise_immediate_loc]
            value[optimal_loc,i] = optimal_cash_flow
    return value

class Price_process
    def __init__(self,data):
        self.data = data
        self.dt = 1/244
        self.N = data.shape[0]-1
        self.r = 3.77/100
    
    def asset_monte_carlo(self,reps,N,r,signma,dt,ind)
        S_0 = self.data.iloc[ind,self.data.columns.get_loc("收盘价")]
        up,df = underlying_price(reps,N,S_0,r,sigma,dt)
        return up,df
    
    def get_specific_day(self):
        self.ipo_day = parse("2017-12-28")
        self.ipo_day_ind = self.data.columns.get_loc(self.ipo_day)
        self.huangu_start_day = parse("2018-11-29")
        self.huangu_start_day_ind = self.data.columns.get_loc(self.huangu_start_day)
        self.maturity_day = parse("2020-11-23")
        self.maturity_day_ind = self.data.columns.get_loc(self.maturity_day)
        self.rate_start_day = parse("2017-11-24")
        self.bond_rate_gap_year = self.data.columns.get_loc(parse("2018-11-29")) - \
        self.data.columns.get_loc(parse("2017-12-28"))+ 24
        
    def specific_day_price(self,ind,reps,T,sigma,K):
        """
        ind代表某一天,2017-12-28为ind为1时的情况应当默认从ind为1开始计算
        """
        S_0 = self.data.iloc[ind,self.data.columns.get_loc("收盘价")]
        self.gap_day = self.data.columns.get_loc(self.huangu_start_day) - self.data.columns.get_loc(start_day)
        N = self.data.iloc[ind:].shape[0] - 1
        up,df = underlying_price(reps,N,S_0,self.r,sigma,self.dt)
        res_sh = {}
        print("------------caculate_回售---------------")
        for i in range(df.shape[0]):
            price = get_redeem_price(df.values[i],1.3*K,K,self.bond_rate_gap_year,discount_year,bond_paper_rate)
            res_sh.update({i:price})

        res_hs = {}
        for i in range(df.shape[0]):
            price = get_redeem_sell_back(df.values[i],0.7*K)
            res_hs.update({i:price})

        other_type = []
        for u in res_sh.keys():
            if (res_sh[u] is None) & (res_hs[u] is None):
                other_type.append(u)
                
        